/*
	Misc utilities that are repeated across different files in content-scripts.
	To access in page context, inject the entire file into the page.
 */

function getDate() { // generated by ChatGPT
    var date = new Date();
    var options = {year: 'numeric', month: 'long', day: 'numeric'};
    return date.toLocaleString('default', options);
}

function getTime() { // generated by ChatGPT
    var currentDate = new Date();
    var options = {
        hour12: true,
        hour: "numeric",
        minute: "numeric"
    };
    var timeString = currentDate.toLocaleTimeString("default", options);
    return timeString
}

function saveChildInnerHTML(parent, clone = true) { // generated by ChatGPT
    // Get the child elements of the parent
    let p1;
    if (clone) {
        p1 = parent.cloneNode(true)
        p1.setAttribute("style", "display: none;");
        mdb.innerHTML = "";
        mdb.appendChild(p1);
    } else {
        p1 = parent
    }
    var children = p1.children;

    // Create a string to store the innerHTML of each child
    var childInnerHTML = '';

    // Loop through each child element
    for (var i = 0; i < children.length; i++) {
        // Clone the child element
        var child = children[i];
        if (child.tagName == "PRE") {
            let div = child.firstChild.children[1]
            div.firstChild.classList.add('p-4')
            let text = div.innerHTML
            let clipboard = `<i class="fa-regular clipboard fa-clipboard"></i>`
            let copy_bar = `<div class="p-2 copy float-right">${clipboard} &nbsp; Copy code</div>`
            let template = `<pre>${copy_bar}<div>${text}</div></pre><br>`
            childInnerHTML += template;
        } else {
            // Remove the child's class attribute
            child.removeAttribute("class");

            // Recursively call the function on the child's children
            saveChildInnerHTML(child, false);

            // Add the child's innerHTML to the string
            childInnerHTML += child.outerHTML;
        }
    }

    return childInnerHTML;
}

function get_current_chat_text()
{
    let mainElement = document.querySelector("main");
    // should be more robust, can't see how they would change the flex col anytime soon
    let chatContainer = mainElement.querySelector(".flex-col");
    // what is one part of a conversation called again? let's just call it a chat bubble
    let chatBubbleElements = chatContainer.children;;
    let chat = [];

    // remember to disregard the last element, which is always a filler element
    for(let i = 0; i < chatBubbleElements.length-1; i++)
    {
        let isHuman = (i % 2) === 0;
        let chatBubble = chatBubbleElements[i];
        let text = get_chat_bubble_text(chatBubble, isHuman);
        chat.push(text);
    }

    return chat;
}

function convert_chat_to_markdown(chat, title)
{
    let string = "";
    if(title)
    {
        string += "# " + title + "\n";
    }
    else
    {
        string += "# " + "ChatGPT Conversation" + "\n";
    }
    string += "\n"; // two newlines because MD is like that
    let convo = chat;
    for(let i = 0; i < convo.length; i++)
    {
        let speaker = i % 2 === 0 ? "Human" : "Assistant";
        string += "**" + speaker + ":**\n";
        string += convo[i] + "\n";
        string += "\n";
        string += "***\n";
        string += "\n";
    }

    // timestamp
    let date = getDate();
    let time = getTime();

    string += "Exported on " + date + " " + time + ".";

    let blob = encode_string_as_blob(string);
    return blob;
}

function encode_string_as_blob(string)
{
    let bytes = new TextEncoder().encode(string);
    let blob = new Blob([bytes], {
        type: "application/json;charset=utf-8"
    });
    return blob;
}
/* conversion functions for export and download */
function convert_thread_to_JSON_file(thread)
{
    let data = thread;
    let string = JSON.stringify(data);
    let blob = encode_string_as_blob(string);
    return blob;
}

function convert_thread_to_text_file(thread)
{
    let string = "Date:" + thread.date + " " + thread.time + "\n";
    let convo = thread.convo;
    for(let i = 0; i < convo.length; i++)
    {
        let speaker = i % 2 === 0 ? "Human" : "Assistant";
        string += speaker + ": " + convo[i] + "\n";
    }
    let blob = encode_string_as_blob(string);
    return blob;
}

// gets chat with errors, for current export.
function get_chat_bubble_text(chatBubble, isHuman)
{
    let text;
    if(isHuman)
    {
        text = chatBubble.innerText;
        if(text.includes("Save & Submit\nCancel"))
        {
            // query the textarea instead
            text = chatBubble.querySelector("textarea")?.value;
        }
        // for code
        text = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    else
    {
        text = saveChildInnerHTML(chatBubble.firstChild.children[1].firstChild.firstChild.firstChild) // saves as html
    }
    return text;
}

// basially using the fileSaver.js, it's an IIFE to save on implementing the <a> singleton.
const download_blob_as_file = (function()
{
    let a = document.createElement("a");
    document.body.appendChild(a);
    a.style = "display: none";
    return function (blob, file_name)
    {
        let url = window.URL.createObjectURL(blob);
        a.href = url;
        a.download = file_name;
        a.click();
        window.URL.revokeObjectURL(url);
    }
})();

function getCssFromSheet(sheet) {
    return Array.from(sheet.cssRules)
        .map((rule) => rule.cssText)
        .join("");
}

function injectScript(file, node) {
    var th = document.getElementsByTagName(node)[0];
    var s = document.createElement('script');
    s.setAttribute('type', 'text/javascript');
    s.setAttribute('src', file);
    th.appendChild(s);
}