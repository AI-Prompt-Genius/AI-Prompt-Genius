browser.storage.local.get(['threads']).then((result) => {
    load_threads(result.threads)
})

const AUTOGENERATED_TITLE_MAX_LENGTH = 100;

let main = document.querySelector(".main")

function delete_thread(i, row){
    browser.storage.local.get(['threads']).then((result) => {
        let t = result.threads
        t.splice(i, 1)
        threads_g = t
        browser.storage.local.set({threads: t})
    });
    row.classList.add('d-none')
}

function export_thread(i){
	browser.storage.local.get(['threads']).then((result) => {
        let t = result.threads
		let thread = t[i];
		
		download_thread_as_json(thread);
	});
}

let timer;
function searchThreads(threads, searchTerm) { // created by ChatGPT
    searchTerm = searchTerm.toLowerCase();
    return threads.filter(thread => {
        return thread.convo.some(message => message.toLowerCase().includes(searchTerm));
    });
}

function search(){
    let search_term = document.querySelector('.search-bar').value
    update_threads()
    let ts = searchThreads(threads_g, document.querySelector('.search-bar').value)
    main.innerHTML = ""
    if (search_term === ""){
        load_threads(threads_g)
    }
    else {
        load_threads(ts, true, search_term)
    }
}

document.querySelector('.search-bar').addEventListener('input', search)

let threads_g = []
let updated = false
function update_threads() {
    clearTimeout(timer)
    if (!updated) {
        browser.storage.local.get(['threads']).then((result) => {
            threads_g = result.threads
        });
    }
    updated = true
    timer = setTimeout(() => {updated = false}, 10000)
}
update_threads()

function update_bookmark(btn, saved){
    if (saved) {
        btn.classList.remove('btn-outline-success')
        btn.classList.add('btn-success')
    }
    else {
        btn.classList.remove('btn-success')
        btn.classList.add('btn-outline-success')
    }
}

function searchList(strings, searchTerm) { // created by ChatGPT
    searchTerm = searchTerm.toLowerCase();
    const matchingStrings = strings.filter(string => string.toLowerCase().includes(searchTerm));

    return matchingStrings.map(string => {
        const index = string.toLowerCase().indexOf(searchTerm);
        const startIndex = Math.max(0, index - 50);
        const endIndex = Math.min(string.length, index + 50);

        let substring = string.substring(startIndex, endIndex);
        if (startIndex > 0) {
            substring = "..." + substring;
        }
        if (endIndex < string.length) {
            substring = substring + "...";
        }

        // use the original case of the search term when highlighting it
        const searchTermRegex = new RegExp(searchTerm, "gi");
        return substring.replace(searchTermRegex, `<span class="highlight">$&</span>`);
    }).join(", ");
}



let dl;
dark_light()
async function dark_light() {
    browser.storage.local.get({mode: "dark"},
        function(result) {
            dl = result.mode
        }
    )
}

function load_threads(threads, search=false, search_term="", bookmarks=false){
    for (let n = 0; n < threads.length; n++) {
        let i = threads.length - n - 1
        let temp;
        let even = n % 2 === 0;
        if (even) {
            temp = document.querySelector('#even').content.cloneNode(true);
        }
        else {
            temp = document.querySelector('#odd').content.cloneNode(true);
        }
        temp.querySelector('.date').innerHTML = threads[i].date
        temp.querySelector('.time').innerHTML = threads[i].time
        temp.querySelector('.title').innerHTML = sliceString(threads[i].convo[0], 55)
        if (!search && threads[i].convo[1] !== undefined) {
            temp.querySelector('.subtitle').innerHTML = sliceString(threads[i].convo[1], AUTOGENERATED_TITLE_MAX_LENGTH)
        }
        else{
            temp.querySelector('.subtitle').innerHTML = sliceString(searchList(threads[i].convo, search_term), AUTOGENERATED_TITLE_MAX_LENGTH)
        }
        let saved = threads[i].favorite
        let btn = temp.querySelector('.btn.bookmark')
        update_bookmark(btn, saved)
        let id = threads[i].id
        if (id === undefined) {
            id = i
        }
        let link = `thread.html?thread=${id}`
        let row = temp.querySelector('.row')
        if (bookmarks){
            if (!saved){
                row.classList.add('d-none')
            }
        }
        if (dl === "light") {
            row.classList.remove('dark')
            row.classList.add('light')
        }
        row.addEventListener('click', event => {
            const target = event.target;
            if (target.classList.contains('trash')){
                delete_thread(i, row)
            }
            else if (target.classList.contains('bookmark')){
                threads[i].favorite = !threads[i].favorite
                browser.storage.local.set({threads: threads})
                let saved = threads[i].favorite
                update_bookmark(btn, saved)
			}
			else if (target.classList.contains('export')) {
				export_thread(i, row);
            } else{
                window.open(link, "_blank")
            }
        });
        main.appendChild(temp)
    }
}
function b_load(){
    load_threads(threads_g, false, "", true)
    document.querySelector('#blink').outerHTML = `<a href="explorer.html" class="mx-3 p-3 text-white text-sm"><i class="fa-solid fa-reel"></i> &emsp; All Threads</a>`
}

function bookmarks() {
    main.innerHTML = ""
    update_threads()
    setTimeout(b_load, 100)
}

function timer_dl(){
    setTimeout(dark_light, 300)
}

function export_all()
{
	browser.storage.local.get(['threads']).then((result) => {
        let t = result.threads;
		let data = t;
		let string = JSON.stringify(data);
		let blob = encode_string_as_blob(string);
		let filename = "ChatGPT-History_data.txt";
		download_blob_as_file(blob, filename);
	});
}

document.querySelectorAll('.bnav').forEach(item => {item.addEventListener('click', bookmarks)})

document.querySelector('#light_dark').addEventListener('click', timer_dl)

document.querySelector("#export_all").addEventListener('click', export_all)